import { useRef, useEffect } from 'react';

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

function useDelayedFunction(originalFunction, delay, catchCancel) {
  var lastCall = useRef({
    timeout: null,
    cancel: null
  }).current;

  function delayedFunction() {
    var _arguments = arguments;

    if (lastCall.cancel) {
      lastCall.cancel();
      lastCall.cancel = null;
    }

    if (lastCall.timeout) {
      clearTimeout(lastCall.timeout);
      lastCall.timeout = null;
    }

    return new Promise(function (resolve, reject) {
      var stillValid = true;

      lastCall.cancel = function (dontReject) {
        stillValid = false;

        if (catchCancel && !dontReject) {
          reject({
            message: 'Function call canceled',
            timestamp: Date.now()
          });
        }
      };

      lastCall.timeout = setTimeout(function () {
        try {
          lastCall.timeout = null;

          var _temp2 = _catch(function () {
            return Promise.resolve(originalFunction && originalFunction.apply(void 0, _arguments)).then(function (result) {
              lastCall.cancel = null;

              if (stillValid) {
                resolve(result);
              }
            });
          }, function (err) {
            lastCall.cancel = null;

            if (stillValid) {
              reject(err);
            }
          });

          return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
        } catch (e) {
          return Promise.reject(e);
        }
      }, typeof delay === 'object' ? delay.current || 0 : delay || 0);
    });
  }

  var cancelIt = function cancelIt(preventReject) {
    if (lastCall.cancel) {
      lastCall.cancel(preventReject);
      lastCall.cancel = null;
    }

    if (lastCall.timeout) {
      clearTimeout(lastCall.timeout);
      lastCall.timeout = null;
    }
  };

  useEffect(function () {
    return function () {
      if (lastCall.cancel) {
        lastCall.cancel(true);
      }

      if (lastCall.timeout) {
        clearTimeout(lastCall.timeout);
      }
    };
  }, []);
  return [delayedFunction, cancelIt];
}

export default useDelayedFunction;
//# sourceMappingURL=index.modern.js.map
