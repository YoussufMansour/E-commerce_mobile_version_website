import React, { useRef, useEffect } from 'react';
import useDelayedFunction from 'use-delayed-function';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function AutoScrollContainer(_ref) {
  var children = _ref.children,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$contentClass = _ref.contentClass,
      contentClass = _ref$contentClass === void 0 ? '' : _ref$contentClass,
      _ref$marginTop = _ref.marginTop,
      marginTop = _ref$marginTop === void 0 ? 0.5 : _ref$marginTop,
      _ref$marginBottom = _ref.marginBottom,
      marginBottom = _ref$marginBottom === void 0 ? 0.5 : _ref$marginBottom,
      _ref$marginLeft = _ref.marginLeft,
      marginLeft = _ref$marginLeft === void 0 ? 0 : _ref$marginLeft,
      _ref$marginRight = _ref.marginRight,
      marginRight = _ref$marginRight === void 0 ? 0 : _ref$marginRight,
      scrollPos = _ref.scrollPos,
      setScrollPos = _ref.setScrollPos,
      focus = _ref.focus,
      setFocus = _ref.setFocus,
      smoothScroll = _ref.smoothScroll,
      _ref$viewMargin = _ref.viewMargin,
      viewMargin = _ref$viewMargin === void 0 ? {
    top: 0.05,
    bottom: 0.05,
    left: 0.05,
    right: 0.05
  } : _ref$viewMargin,
      _ref$autoScrollOnFocu = _ref.autoScrollOnFocus,
      autoScrollOnFocus = _ref$autoScrollOnFocu === void 0 ? true : _ref$autoScrollOnFocu,
      _ref$debouncingDelay = _ref.debouncingDelay,
      debouncingDelay = _ref$debouncingDelay === void 0 ? 200 : _ref$debouncingDelay,
      _ref$keyboardPopDelay = _ref.keyboardPopDelay,
      keyboardPopDelay = _ref$keyboardPopDelay === void 0 ? 1500 : _ref$keyboardPopDelay,
      _ref$signature = _ref.signature,
      signature = _ref$signature === void 0 ? 'data-auto-scroll-container-signature' : _ref$signature;
  var scrollDiv = useRef();
  var contentDiv = useRef();
  var rightMarginDiv = useRef();
  var currentFocus = useRef(null);
  var childObserver = useRef(null);
  var mobileKeyboard = useRef(false);
  var justFocused = useRef(false);
  var prevViewMargin = useRef();

  var _useDelayedFunction = useDelayedFunction(calcDivSize, debouncingDelay),
      debounceResize = _useDelayedFunction[0];

  var _useDelayedFunction2 = useDelayedFunction(setJustFocused, keyboardPopDelay),
      setJustFocusedLater = _useDelayedFunction2[0];

  var scroll = useRef({
    initializing: true,
    isAutoScrolling: false,
    immediateChild: null,
    divSize: undefined,
    margins: undefined,
    content: undefined,
    pos: {
      x: (scrollPos === null || scrollPos === void 0 ? void 0 : scrollPos.scrollX) || 0,
      offsetX: scrollPos ? scrollPos.viewX === undefined ? 0.1 : scrollPos.viewX : 0.1,
      y: (scrollPos === null || scrollPos === void 0 ? void 0 : scrollPos.scrollY) || 0,
      offsetY: scrollPos ? scrollPos.viewY === undefined ? 0.1 : scrollPos.viewY : 0.1
    }
  }).current;

  function setMobileKeyboard(status) {
    mobileKeyboard.current = status;
  }

  function setJustFocused(status) {
    justFocused.current = status;
  }

  var handleScroll = function handleScroll(e) {
    if (scroll.isAutoScrolling) {
      scroll.isAutoScrolling = false;
      return;
    }

    if (mobileKeyboard.current) {
      scrollToNewPos(_extends({}, scroll.pos, {}, compensatedOffsets()));
      return;
    }

    scroll.pos = currentPos();
    setPosState();
  };

  var handleFocus = function handleFocus(e) {
    removeChildObserver();
    currentFocus.current = e.target;

    if (setFocus) {
      setFocus(function () {
        return {
          element: currentFocus.current
        };
      });
    }

    scroll.immediateChild = null;
    scroll.pos = currentPos();
    addChildObserver();

    if (autoScrollOnFocus) {
      setJustFocused(true);
      scrollToNewPos(_extends({}, scroll.pos, {}, compensatedOffsets()));
      setJustFocusedLater(false);
    }

    setPosState();
  };

  var handleBlure = function handleBlure(e) {
    removeChildObserver();
    currentFocus.current = null;

    if (setFocus) {
      setFocus(function () {
        return null;
      });
    }

    scroll.pos = currentPos();
    setPosState();
  };

  function addChildObserver() {
    if (scroll.immediateChild === null) return;
    scroll.immediateChild.setAttribute(signature, '0');
    childObserver.current.observe(scroll.immediateChild, {
      attributes: true,
      attributesFilter: [signature]
    });
  }

  function removeChildObserver() {
    if (scroll.immediateChild === null) return;
    childObserver.current.disconnect();
  }

  function resizeParent() {
    var value = Number(scrollDiv.current.getAttribute(signature));
    scrollDiv.current.setAttribute(signature, (value + 1).toString());
  }

  function resizeByChild() {
    if (scroll.initializing) return;
    calcDivSize();
    setMobileKeyboard(false);
    adjustScroll();
    resizeParent();
  }

  function handleResize() {
    if (scroll.initializing) return;

    if (justFocused.current) {
      setMobileKeyboard(true);
    }

    if (scroll.immediateChild) return;
    debounceResize().then(function () {
      setMobileKeyboard(false);
      adjustScroll();
      resizeParent();
    });
  }

  useEffect(function () {
    window.addEventListener('resize', handleResize);
    return function () {
      window.removeEventListener('resize', handleResize);
    };
  });
  useEffect(function () {
    if (scroll.initializing || !scrollPos) return;

    if (scrollPos.autoScroll) {
      scrollPos.autoScroll = false;
      return;
    }

    var _scrollPos$scrollX = scrollPos.scrollX,
        scrollX = _scrollPos$scrollX === void 0 ? 0 : _scrollPos$scrollX,
        _scrollPos$viewX = scrollPos.viewX,
        viewX = _scrollPos$viewX === void 0 ? 0.1 : _scrollPos$viewX,
        _scrollPos$scrollY = scrollPos.scrollY,
        scrollY = _scrollPos$scrollY === void 0 ? 0 : _scrollPos$scrollY,
        _scrollPos$viewY = scrollPos.viewY,
        viewY = _scrollPos$viewY === void 0 ? 0.1 : _scrollPos$viewY;
    scroll.pos = {
      x: scrollX,
      offsetX: viewX,
      y: scrollY,
      offsetY: viewY
    };
    scrollToNewPos(_extends({}, scroll.pos));
  }, [scrollPos]);
  useEffect(function () {
    if (scroll.initializing) return;
    adjustScroll();
  }, [marginTop, marginBottom, marginLeft, marginRight]);
  useEffect(function () {
    if (scroll.initializing) return;

    if (prevViewMargin.current) {
      var _prevViewMargin$curre = prevViewMargin.current,
          top = _prevViewMargin$curre.top,
          bottom = _prevViewMargin$curre.bottom,
          left = _prevViewMargin$curre.left,
          right = _prevViewMargin$curre.right;

      if (viewMargin.top != top || viewMargin.bottom != bottom || viewMargin.left != left || viewMargin.right != right) {
        adjustScroll();
      }
    }

    return function () {
      prevViewMargin.current = viewMargin;
    };
  }, [viewMargin]);
  useEffect(function () {
    scrollDiv.current.setAttribute(signature, '0');
    childObserver.current = new MutationObserver(resizeByChild);
    return function () {
      childObserver.current.disconnect();
    };
  }, []);
  useEffect(function () {
    if (!smoothScroll) return;
    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
    var cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
    var _smoothScroll$smoothF = smoothScroll.smoothFunction,
        smoothFunction = _smoothScroll$smoothF === void 0 ? function (x) {
      return 1 - Math.pow(1 - x, 3);
    } : _smoothScroll$smoothF,
        _smoothScroll$duratio = smoothScroll.duration,
        duration = _smoothScroll$duratio === void 0 ? 800 : _smoothScroll$duratio,
        _smoothScroll$scrollX = smoothScroll.scrollX,
        fx = _smoothScroll$scrollX === void 0 ? 0 : _smoothScroll$scrollX,
        _smoothScroll$scrollY = smoothScroll.scrollY,
        fy = _smoothScroll$scrollY === void 0 ? 0 : _smoothScroll$scrollY,
        _smoothScroll$viewX = smoothScroll.viewX,
        fvx = _smoothScroll$viewX === void 0 ? 0.1 : _smoothScroll$viewX,
        _smoothScroll$viewY = smoothScroll.viewY,
        fvy = _smoothScroll$viewY === void 0 ? 0.1 : _smoothScroll$viewY;
    var _scroll$pos = scroll.pos,
        sx = _scroll$pos.x,
        sy = _scroll$pos.y,
        svx = _scroll$pos.offsetX,
        svy = _scroll$pos.offsetY;
    var startTime;
    var lastAnimationID;

    function smoothPos(timestamp) {
      if (startTime === undefined) {
        startTime = timestamp;
      }

      var passedT = timestamp - startTime;
      var r = smoothFunction(passedT / duration);
      scroll.pos = {
        x: sx + (fx - sx) * r,
        y: sy + (fy - sy) * r,
        offsetX: svx + (fvx - svx) * r,
        offsetY: svy + (fvy - svy) * r
      };
      scrollToNewPos(_extends({}, scroll.pos));
      scroll.pos = currentPos();
      setPosState();

      if (passedT < duration) {
        lastAnimationID = requestAnimationFrame(smoothPos);
      }
    }

    lastAnimationID = requestAnimationFrame(smoothPos);
    return function () {
      cancelAnimationFrame(lastAnimationID);
    };
  }, [smoothScroll]);
  useEffect(function () {
    scrollDiv.current.style.visibility = 'hidden';
    setPositionRelative();
    calcDivSize();
    adjustScroll();
    scroll.initializing = false;
    scrollDiv.current.style.visibility = 'visible';
  }, []);
  useEffect(function () {
    if (!focus || !focus.element || currentFocus.current === focus.element) return;
    focus.element.focus();
  }, [focus]);

  function relativeOffset(element) {
    if (!element) {
      return [0, 0];
    }

    var elementParent = element.offsetParent;
    var x = element.offsetLeft;
    var y = element.offsetTop;

    if (elementParent === rightMarginDiv.current.offsetParent || !elementParent) {
      return [x, y];
    } else {
      if (elementParent.hasAttribute(signature)) {
        scroll.immediateChild = elementParent;
      }

      var _relativeOffset = relativeOffset(elementParent),
          xParent = _relativeOffset[0],
          yParent = _relativeOffset[1];

      return [x + xParent - elementParent.scrollLeft, y + yParent - elementParent.scrollTop];
    }
  }

  function compensatedOffsets() {
    var divSize = scroll.divSize,
        pos = scroll.pos;
    var offsetY = pos.offsetY;
    var offsetX = pos.offsetX;

    if (currentFocus.current) {
      var _currentFocus$current = currentFocus.current.getBoundingClientRect(),
          height = _currentFocus$current.height,
          width = _currentFocus$current.width;

      var _viewMargin$top = viewMargin.top,
          top = _viewMargin$top === void 0 ? 0 : _viewMargin$top,
          _viewMargin$bottom = viewMargin.bottom,
          bottom = _viewMargin$bottom === void 0 ? 0 : _viewMargin$bottom,
          _viewMargin$left = viewMargin.left,
          left = _viewMargin$left === void 0 ? 0 : _viewMargin$left,
          _viewMargin$right = viewMargin.right,
          right = _viewMargin$right === void 0 ? 0 : _viewMargin$right;
      var hRatio = height / divSize.height;
      var wRatio = width / divSize.width;

      if (top + hRatio + bottom > 1) {
        if (offsetY + hRatio / 2 > 0.5) {
          offsetY = top;
        } else {
          offsetY = 1 - hRatio - bottom;
        }
      } else {
        if (offsetY < top) {
          offsetY = top;
        }

        if (offsetY + hRatio > 1 - bottom) {
          offsetY = 1 - bottom - hRatio;
        }
      }

      if (left + wRatio + right > 1) {
        if (offsetX + wRatio / 2 > 0.5) {
          offsetX = left;
        } else {
          offsetX = 1 - wRatio - right;
        }
      } else {
        if (offsetX < left) {
          offsetX = left;
        }

        if (offsetX + wRatio > 1 - right) {
          offsetX = 1 - right - wRatio;
        }
      }
    }

    return {
      offsetY: offsetY,
      offsetX: offsetX
    };
  }

  function adjustScroll() {
    calcMargins();
    setMargins();
    calcContent();
    scrollToNewPos(_extends({}, scroll.pos, {}, compensatedOffsets()));
    scroll.pos = currentPos();
    setPosState();
  }

  function currentPos() {
    var divSize = scroll.divSize,
        content = scroll.content,
        margins = scroll.margins;

    var _ref2 = scrollPos || {
      viewX: 0.1,
      viewY: 0.1
    },
        _ref2$viewX = _ref2.viewX,
        viewX = _ref2$viewX === void 0 ? 0.1 : _ref2$viewX,
        _ref2$viewY = _ref2.viewY,
        viewY = _ref2$viewY === void 0 ? 0.1 : _ref2$viewY;

    var top = scrollDiv.current.scrollTop;
    var left = scrollDiv.current.scrollLeft;

    var _ref3 = currentFocus.current ? relativeOffset(currentFocus.current) : [left + viewX * divSize.width, top + viewY * divSize.height],
        x = _ref3[0],
        y = _ref3[1];

    return {
      x: (x - margins.left) / content.width,
      y: (y - margins.top) / content.height,
      offsetX: (x - left) / divSize.width,
      offsetY: (y - top) / divSize.height
    };
  }

  function setPosState() {
    if (!setScrollPos) return;
    var _scroll$pos2 = scroll.pos,
        x = _scroll$pos2.x,
        y = _scroll$pos2.y,
        offsetX = _scroll$pos2.offsetX,
        offsetY = _scroll$pos2.offsetY;
    setScrollPos(function () {
      return {
        scrollX: x,
        viewX: offsetX,
        scrollY: y,
        viewY: offsetY,
        autoScroll: true
      };
    });
  }

  function scrollToNewPos(_ref4) {
    var x = _ref4.x,
        y = _ref4.y,
        offsetX = _ref4.offsetX,
        offsetY = _ref4.offsetY;
    var content = scroll.content,
        divSize = scroll.divSize,
        margins = scroll.margins;
    scroll.isAutoScrolling = true;
    scrollDiv.current.scrollTop = y * content.height - offsetY * divSize.height + margins.top;
    scrollDiv.current.scrollLeft = x * content.width - offsetX * divSize.width + margins.left;
  }

  function setPositionRelative() {
    if (getComputedStyle(scrollDiv.current).position === 'static') {
      scrollDiv.current.style.position = 'relative';
    }
  }

  function calcDivSize() {
    var rect = scrollDiv.current.getBoundingClientRect();
    scroll.divSize = {
      width: rect.width,
      height: Math.min(rect.height, document.documentElement.clientHeight)
    };
  }

  function calcMargins() {
    var _scroll$divSize = scroll.divSize,
        width = _scroll$divSize.width,
        height = _scroll$divSize.height;
    scroll.margins = {
      top: marginTop * height,
      bottom: marginBottom * height,
      left: marginLeft * width,
      right: marginRight * width
    };
  }

  function setMargins() {
    var _scroll$margins = scroll.margins,
        top = _scroll$margins.top,
        bottom = _scroll$margins.bottom,
        left = _scroll$margins.left,
        right = _scroll$margins.right;
    var contentStyle = contentDiv.current.style;

    if (marginTop) {
      contentStyle.marginTop = top + "px";
    }

    if (marginBottom) {
      contentStyle.marginBottom = bottom + "px";
    }

    if (marginLeft) {
      rightMarginDiv.current.style.left = left + "px";
      contentStyle.marginLeft = left + "px";
    }

    if (marginRight) {
      rightMarginDiv.current.style.left = scrollDiv.current.scrollWidth + right + "px";
    }
  }

  function calcContent() {
    var _scroll$margins2 = scroll.margins,
        top = _scroll$margins2.top,
        bottom = _scroll$margins2.bottom,
        left = _scroll$margins2.left,
        right = _scroll$margins2.right;
    scroll.content = {
      width: scrollDiv.current.scrollWidth - left - right,
      height: scrollDiv.current.scrollHeight - top - bottom
    };
  }

  return /*#__PURE__*/React.createElement("div", {
    ref: scrollDiv,
    className: className,
    onScroll: handleScroll,
    onFocus: handleFocus,
    onBlurCapture: handleBlure
  }, /*#__PURE__*/React.createElement("div", {
    ref: rightMarginDiv,
    style: {
      position: 'absolute',
      width: '1px',
      height: '1px',
      top: '0px',
      visibility: 'hidden'
    }
  }), /*#__PURE__*/React.createElement("div", {
    ref: contentDiv,
    className: contentClass
  }, children));
}

export default AutoScrollContainer;
//# sourceMappingURL=index.modern.js.map
